#!/usr/bin/env node

/**
 * Generate checksums for all template files
 * This is run at build time to create a registry of known template versions
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const glob = require('glob');

// Canonicalize content (same logic as TypeScript version)
function canonicalizeContent(content, fileType) {
  // Normalize line endings to LF
  let normalized = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  
  // File-type specific canonicalization first (when applicable)
  const ext = (fileType || '').toLowerCase();
  
  if (ext === '.json') {
    try {
      // Parse and re-stringify JSON with sorted keys for consistent ordering
      const obj = JSON.parse(normalized);
      // Sort keys recursively
      const sortKeys = (o) => {
        if (Array.isArray(o)) {
          return o.map(sortKeys);
        } else if (o !== null && typeof o === 'object') {
          return Object.keys(o).sort().reduce((result, key) => {
            result[key] = sortKeys(o[key]);
            return result;
          }, {});
        }
        return o;
      };
      const sorted = sortKeys(obj);
      normalized = JSON.stringify(sorted, null, 2) + '\n';
    } catch {
      // If JSON parsing fails, fall through to generic normalization
    }
  } else if (ext === '.md' || ext === '.mdc') {
    // Normalize YAML front-matter if present
    const frontMatterMatch = normalized.match(/^---\n([\s\S]*?)\n---\n?/);
    if (frontMatterMatch) {
      const frontMatter = frontMatterMatch[1];
      const body = normalized.slice(frontMatterMatch[0].length);
      
      // Parse and normalize front-matter
      const frontMatterMap = {};
      frontMatter.split('\n').forEach(line => {
        const match = line.match(/^([A-Za-z0-9_-]+):\s*(.*)$/);
        if (match) {
          frontMatterMap[match[1]] = match[2];
        }
      });
      
      // Rebuild with sorted keys
      const sortedKeys = Object.keys(frontMatterMap).sort();
      const rebuiltFrontMatter = sortedKeys
        .map(key => `${key}: ${frontMatterMap[key]}`)
        .join('\n');
      
      normalized = `---\n${rebuiltFrontMatter}\n---\n${body}`;
    }
  }
  
  // Generic whitespace normalization (applies to all file types)
  normalized = normalized.split('\n')
    .map(line => line.trimEnd())
    .join('\n');
  
  // Remove excessive trailing newlines (keep just one)
  normalized = normalized.trimEnd();
  if (normalized.length > 0) {
    normalized += '\n';
  }
  
  // Remove BOM if present
  if (normalized.charCodeAt(0) === 0xFEFF) {
    normalized = normalized.slice(1);
  }
  
  return normalized;
}

function calculateChecksum(content, fileType) {
  const canonical = canonicalizeContent(content, fileType);
  return crypto.createHash('sha256').update(canonical, 'utf8').digest('hex');
}

// Template patterns to include
const templatePatterns = [
  'src/claude-templates/*.md',
  'src/claude-templates/*.template',
  'src/cursor-templates/*.mdc',
];

// Collect all checksums
const checksums = {};

// Process current templates
console.log('Generating template checksums...');

templatePatterns.forEach(pattern => {
  const files = glob.sync(pattern, { cwd: __dirname + '/..' });
  
  files.forEach(file => {
    const fullPath = path.join(__dirname, '..', file);
    const content = fs.readFileSync(fullPath, 'utf8');
    const fileName = path.basename(file);
    const fileExt = path.extname(fileName).toLowerCase();
    const checksum = calculateChecksum(content, fileExt);
    
    if (!checksums[fileName]) {
      checksums[fileName] = [];
    }
    
    // Add current version checksum
    if (!checksums[fileName].includes(checksum)) {
      checksums[fileName].push(checksum);
      console.log(`  ‚úì ${fileName}: ${checksum.substring(0, 8)}...`);
    }
  });
});

// Load previous checksums if they exist
const previousChecksumsPath = path.join(__dirname, 'previous-checksums.json');
if (fs.existsSync(previousChecksumsPath)) {
  console.log('Loading previous version checksums...');
  const previousData = JSON.parse(fs.readFileSync(previousChecksumsPath, 'utf8'));
  
  // Skip the comment field and process only arrays
  Object.keys(previousData).forEach(fileName => {
    if (fileName === 'comment' || !Array.isArray(previousData[fileName])) {
      return;
    }
    
    if (!checksums[fileName]) {
      checksums[fileName] = [];
    }
    
    previousData[fileName].forEach(checksum => {
      if (!checksums[fileName].includes(checksum)) {
        checksums[fileName].push(checksum);
      }
    });
  });
}

// Generate TypeScript file
const tsContent = `/**
 * Auto-generated template checksums
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-checksums.js
 */

export const TEMPLATE_CHECKSUMS: Record<string, string[]> = ${JSON.stringify(checksums, null, 2)};

/**
 * Check if a file content matches any known template version
 */
export function isKnownTemplateVersion(fileName: string, checksum: string): boolean {
  const known = TEMPLATE_CHECKSUMS[fileName];
  return known ? known.includes(checksum) : false;
}

/**
 * Get all known checksums for a template file
 */
export function getKnownChecksums(fileName: string): string[] {
  return TEMPLATE_CHECKSUMS[fileName] || [];
}
`;

// Write TypeScript file
const outputPath = path.join(__dirname, '..', 'src', 'utils', 'template-checksums.ts');
fs.writeFileSync(outputPath, tsContent);

console.log(`\n‚úì Generated ${outputPath}`);
console.log(`  Total templates: ${Object.keys(checksums).length}`);
console.log(`  Total checksums: ${Object.values(checksums).reduce((sum, arr) => sum + arr.length, 0)}`);

// Check if previous-checksums.json needs updating
const previousData = fs.existsSync(previousChecksumsPath) 
  ? JSON.parse(fs.readFileSync(previousChecksumsPath, 'utf8'))
  : { comment: "Historical checksums from previous versions - maintain this file to track known versions" };

let needsUpdate = false;
const updatedPreviousData = { ...previousData };

Object.keys(checksums).forEach(fileName => {
  const currentChecksum = checksums[fileName][0]; // First checksum is current version
  const previousChecksums = previousData[fileName] || [];
  
  // Check if current checksum is not in previous checksums
  if (currentChecksum && !previousChecksums.includes(currentChecksum)) {
    needsUpdate = true;
    console.log(`\n‚ö†Ô∏è  Template changed: ${fileName}`);
    console.log(`  New checksum: ${currentChecksum.substring(0, 16)}...`);
    if (previousChecksums.length > 0) {
      console.log(`  Previous checksums: ${previousChecksums.length} known version(s)`);
    }
    
    // Automatically add the old checksum to previous-checksums.json if we're in a release
    // The "old" checksum is what was in previous-checksums before this build
    if (process.env.CI && process.env.GITHUB_REF_TYPE === 'tag') {
      console.log(`  üìù Auto-preserving previous version checksum for backward compatibility`);
      // Add the PREVIOUS current checksum (from last release) to the list
      // This happens when we're building a new release
      if (!updatedPreviousData[fileName]) {
        updatedPreviousData[fileName] = [];
      }
      // The checksum that WAS current is now historical
      // We get it from what was already in previous-checksums.json
      const lastReleaseChecksum = previousChecksums[0];
      if (lastReleaseChecksum && !updatedPreviousData[fileName].includes(lastReleaseChecksum)) {
        updatedPreviousData[fileName].push(lastReleaseChecksum);
      }
    }
  }
});

if (needsUpdate) {
  console.log('\n' + '='.repeat(60));
  console.log('‚ö†Ô∏è  IMPORTANT: Template checksums have changed!');
  console.log('='.repeat(60));
  
  // In CI during a release, auto-update the previous-checksums.json
  if (process.env.CI && process.env.GITHUB_REF_TYPE === 'tag') {
    console.log('\n‚úÖ CI Release Mode: Auto-updating previous-checksums.json');
    
    // Ensure all current checksums are preserved for the NEXT release
    Object.keys(checksums).forEach(fileName => {
      const currentChecksum = checksums[fileName][0];
      if (!updatedPreviousData[fileName]) {
        updatedPreviousData[fileName] = [];
      }
      // Add current checksum if not already there
      if (currentChecksum && !updatedPreviousData[fileName].includes(currentChecksum)) {
        updatedPreviousData[fileName].unshift(currentChecksum); // Add at beginning
      }
    });
    
    // Write the updated file
    fs.writeFileSync(previousChecksumsPath, JSON.stringify(updatedPreviousData, null, 2) + '\n');
    console.log('‚úÖ Updated previous-checksums.json with current version checksums');
    console.log('   These will be recognized as valid in future updates');
  } else if (process.env.CI) {
    // In CI but not a release - this is a regular build/test
    console.log('\n‚ö†Ô∏è  CI Build: Template checksums changed');
    console.log('This is expected during development. Release builds will auto-preserve checksums.');
  } else {
    // Local development
    console.log('\nTo preserve backward compatibility, you should:');
    console.log('1. Update previous-checksums.json with the current checksums');
    console.log('2. Keep existing checksums to recognize older versions');
    console.log('\nRun this command to see the changes:');
    console.log('  git diff scripts/previous-checksums.json');
  }
}